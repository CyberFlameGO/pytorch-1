import numpy as np
import sys
import torch

from datetime import datetime
from dextr.model import DextrModel
from skimage import measure
from opex import ObjectPredictions, ObjectPrediction, BBox, Polygon


def load_model(model_path=None, device=None):
    """
    Loads and returns the DEXTR model to use for inference.

    :param model_path: the model to load, uses pretrained resunet101 if None
    :type model_path: str
    :param device: the torch device to use the model on, eg 'cpu', 'cuda:0'
    :type device: str
    :return: the model
    :rtype: DextrModel
    """
    if device is None:
        if torch.cuda.is_available():
            device = 'cuda:0'
        else:
            device = 'cpu'

    torch_device = torch.device(device)

    # Load model
    if model_path is not None:
        # A model path was provided; load it
        result = torch.load(model_path, map_location=torch_device)
    else:
        # No model path; download (if necessary) and load a pre-trained model
        result = DextrModel.pascalvoc_resunet101().to(torch_device)

    result.eval()

    return result


def predict(model, image, points, threshold=0.5, label=1):
    """
    Performs a prediction on the image numpy array using the provided extreme points.

    :param model: the DEXTR model to use for inference
    :type model: DextrModel
    :param image: the image to use
    :type image: PIL.Image
    :param points: either a (4,2) numpy array or list of list (of x/y)
    :param threshold: the threshold to apply to the mask and contour finding (0-1)
    :type threshold: float
    :param label: the label (int) to use in the generated mask
    :type label: int
    :return: tuple of binary mask numpy array and list of contours (N,2 numpy arrays)
    """
    if isinstance(points, list):
        extreme_points = np.array(points)
    else:
        extreme_points = points

    masks = model.predict([image], extreme_points[None, :, ::-1])

    mask_bin = (masks[0] >= threshold).astype(np.uint8)
    if label != 1:
        mask_bin[mask_bin == 1] = label
    contours = measure.find_contours(masks[0], threshold, fully_connected='high')

    return mask_bin, contours


def contours_to_list(contours):
    """
    Turns each contour generated by scikit image into a list of x/y tuples.

    :param contours: the contours to convert (list of numpy arrays)
    :type contours: list
    :return: the list of contour lists
    :rtype: list
    """
    result = []
    for contour in contours:
        points = []
        for i in range(len(contour)):
            points.append((int(contour[i, 1]), int(contour[i, 0])))
        result.append(points)
    return result


def contours_to_opex(contours, id=None, label="object"):
    """
    Turns the contours generated by scikit image into OPEX format.

    :param contours: the contours to convert (list of lists)
    :type contours: list
    :param id: the ID to use in the OPEX output, uses current timestamp if None
    :type id: str
    :param label: the label to use in the OPEX output
    :type label: str
    :return: the OPEX predictions
    :rtype: ObjectPredictions
    """
    opex_preds = []
    for contour in contours:
        points = []
        minx = sys.maxsize
        maxx = 0
        miny = sys.maxsize
        maxy = 0
        for coords in contour:
            x = coords[0]
            y = coords[1]
            minx = min(minx, x)
            maxx = max(maxx, x)
            miny = min(miny, y)
            maxy = max(maxy, y)
            points.append((x, y))
        poly = Polygon(points=points)
        bbox = BBox(left=minx, top=miny, right=maxx, bottom=maxy)
        opex_pred = ObjectPrediction(label=label, bbox=bbox, polygon=poly)
        opex_preds.append(opex_pred)
    ts = str(datetime.now())
    if id is None:
        id = ts
    results = ObjectPredictions(id=id, timestamp=ts, objects=opex_preds)
    return results
